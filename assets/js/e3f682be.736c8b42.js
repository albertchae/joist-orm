"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[679],{5318:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(7378);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,l=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),c=d(n),m=i,f=c["".concat(s,".").concat(m)]||c[m]||u[m]||l;return n?a.createElement(f,r(r({ref:t},p),{},{components:n})):a.createElement(f,r({ref:t},p))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=n.length,r=new Array(l);r[0]=c;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,r[1]=o;for(var d=2;d<l;d++)r[d]=n[d];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},4813:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>l,metadata:()=>o,toc:()=>d});var a=n(5773),i=(n(7378),n(5318));const l={title:"Fields",sidebar_position:1},r=void 0,o={unversionedId:"modeling/fields",id:"modeling/fields",title:"Fields",description:"Fields are the primitive columns in your domain model, so all of the (non-foreign key) int, varchar, datetime, etc. columns.",source:"@site/docs/modeling/fields.md",sourceDirName:"modeling",slug:"/modeling/fields",permalink:"/docs/modeling/fields",draft:!1,editUrl:"https://github.com/stephen/joist-ts/edit/main/docs/docs/modeling/fields.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Fields",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Great Tests",permalink:"/docs/goals/great-tests"},next:{title:"Relations",permalink:"/docs/modeling/relations"}},s={},d=[{value:"Optional vs Required",id:"optional-vs-required",level:2},{value:"Using <code>undefined</code> instead of <code>null</code>",id:"using-undefined-instead-of-null",level:3},{value:"Type Checked Construction",id:"type-checked-construction",level:3},{value:"Partial Updates Semantics",id:"partial-updates-semantics",level:3},{value:"Protected Fields",id:"protected-fields",level:2},{value:"Field Defaults",id:"field-defaults",level:2},{value:"Schema Defaults",id:"schema-defaults",level:3},{value:"Dynamic Defaults",id:"dynamic-defaults",level:3},{value:"Hooks",id:"hooks",level:3}],p={toc:d};function u(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Fields are the primitive columns in your domain model, so all of the (non-foreign key) ",(0,i.kt)("inlineCode",{parentName:"p"},"int"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"varchar"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"datetime"),", etc. columns."),(0,i.kt)("p",null,"For these columns, Joist automatically adds getters & setters to your domain model, i.e. an ",(0,i.kt)("inlineCode",{parentName:"p"},"authors.first_name")," column will have getters & setters added to ",(0,i.kt)("inlineCode",{parentName:"p"},"AuthorCodegen.ts"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'// This code is auto-generated\nclass AuthorCodegen {\n  get firstName(): string {\n    return this.__orm.data["firstName"];\n  }\n\n  set firstName(firstName: string) {\n    setField(this, "firstName", firstName);\n  }\n}\n')),(0,i.kt)("h2",{id:"optional-vs-required"},"Optional vs Required"),(0,i.kt)("p",null,"Joist's fields model ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"not null")," appropriately, e.g. for a table like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'                     Table "public.authors"\n    Column    |           Type           | Nullable\n--------------+--------------------------+----------+\n id           | integer                  | not null |\n first_name   | character varying(255)   | not null |\n last_name    | character varying(255)   |          |\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Author")," domain object will type ",(0,i.kt)("inlineCode",{parentName:"p"},"firstName")," as a ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"lastName")," as ",(0,i.kt)("inlineCode",{parentName:"p"},"string | undefined"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"class AuthorCodegen {\n  get firstName(): string { ... }\n  set firstName(firstName: string) { ... }\n  get lastName(): string | undefined { ... }\n  set lastName(lastName: string | undefined) { ... }\n}\n")),(0,i.kt)("h3",{id:"using-undefined-instead-of-null"},"Using ",(0,i.kt)("inlineCode",{parentName:"h3"},"undefined")," instead of ",(0,i.kt)("inlineCode",{parentName:"h3"},"null")),(0,i.kt)("p",null,"Joist uses ",(0,i.kt)("inlineCode",{parentName:"p"},"undefined")," to represent nullable columns, i.e. in the ",(0,i.kt)("inlineCode",{parentName:"p"},"Author")," example, the ",(0,i.kt)("inlineCode",{parentName:"p"},"lastName")," type is ",(0,i.kt)("inlineCode",{parentName:"p"},"string | undefined")," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"string | null")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"string | null | undefined"),"."),(0,i.kt)("p",null,'The rationale for this is simplicity, and Joist\'s preference for "idiomatic TypeScript", which for the most part has eschewed the "when to use ',(0,i.kt)("inlineCode",{parentName:"p"},"undefined")," vs. ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),' in JavaScript?" decision by going with "just use ',(0,i.kt)("inlineCode",{parentName:"p"},"undefined"),'."'),(0,i.kt)("h3",{id:"type-checked-construction"},"Type Checked Construction"),(0,i.kt)("p",null,"The non-null ",(0,i.kt)("inlineCode",{parentName:"p"},"Author.firstName")," field is enforced as required on construction:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'// Valid\nnew Author(em, { firstName: "bob" });\n// Not valid\nnew Author(em, {});\n// Not valid\nnew Author(em, { firstName: null });\n// Not valid\nnew Author(em, { firstName: undefined });\n')),(0,i.kt)("p",null,"And for updates made via the ",(0,i.kt)("inlineCode",{parentName:"p"},"set")," method:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'// Valid\nauthor.set({ firstName: "bob" });\n// Valid, because `set` accepts a Partial\nauthor.set({});\n// Not valid\nauthor.set({ firstName: null });\n// Technically valid b/c `set` accepts a Partial, but is a noop\nauthor.set({ firstName: undefined });\n')),(0,i.kt)("h3",{id:"partial-updates-semantics"},"Partial Updates Semantics"),(0,i.kt)("p",null,"While within internal business logic ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," vs. ",(0,i.kt)("inlineCode",{parentName:"p"},"undefined")," is not really a useful distinction, when building APIs ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),' can be a useful value to signify "unset" (vs. ',(0,i.kt)("inlineCode",{parentName:"p"},"undefined"),' which typically signifies "don\'t change").'),(0,i.kt)("p",null,"For this use case, domain objects have a ",(0,i.kt)("inlineCode",{parentName:"p"},".setPartial")," that accepts null versions of properties:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'// Partial update from an API operation\nconst updateFromApi = {\n  firstName: null\n};\n// Allowed\nauthor.setPartial(updateFromApi);\n// Outputs "undeifned" b/c null is still translated to undefined\nconsole.log(author.firstName);\n')),(0,i.kt)("p",null,"Note that, when using ",(0,i.kt)("inlineCode",{parentName:"p"},"setPartial")," we have caused our ",(0,i.kt)("inlineCode",{parentName:"p"},"Author.firstName: string")," getter to now be incorrect, i.e. for a currently invalid ",(0,i.kt)("inlineCode",{parentName:"p"},"Author"),", clients might observe ",(0,i.kt)("inlineCode",{parentName:"p"},"firstName")," as ",(0,i.kt)("inlineCode",{parentName:"p"},"undefined"),"."),(0,i.kt)("p",null,"See ",(0,i.kt)("a",{parentName:"p",href:"/docs/features/partial-update-apis"},"Partial Update APIs")," for more details."),(0,i.kt)("h2",{id:"protected-fields"},"Protected Fields"),(0,i.kt)("p",null,"You can mark a field as protected in ",(0,i.kt)("inlineCode",{parentName:"p"},"joist-config.json"),", which will make the setter ",(0,i.kt)("inlineCode",{parentName:"p"},"protected"),", so that only your entity's internal business logic can call it."),(0,i.kt)("p",null,"The getter will still be public."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "entities": {\n    "Author": {\n      "fields": {\n        "wasEverPopular": { "protected": true }\n      }\n    }\n  }\n}\n')),(0,i.kt)("h2",{id:"field-defaults"},"Field Defaults"),(0,i.kt)("h3",{id:"schema-defaults"},"Schema Defaults"),(0,i.kt)("p",null,"If your database schema has default values for columns, i.e. an integer that defaults to 0, Joist will immediately apply those defaults to entities as they're created, i.e. via ",(0,i.kt)("inlineCode",{parentName:"p"},"em.create"),"."),(0,i.kt)("p",null,"This gives your business logic immediate access to the default value that would be applied by the database, but without waiting for an ",(0,i.kt)("inlineCode",{parentName:"p"},"em.flush")," to happen."),(0,i.kt)("h3",{id:"dynamic-defaults"},"Dynamic Defaults"),(0,i.kt)("p",null,"If you need to use ",(0,i.kt)("inlineCode",{parentName:"p"},"async"),", cross-entity business logic to set field defaults, you can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"config.setDefault")," method:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'/** Example of a synchronous default. */\nconfig.setDefault("notes", (b) => `Notes for ${b.title}`);\n\n/** Example of an asynchronous default. */\nconfig.setDefault("order", { author: "books" }, (b) => b.author.get.books.get.length);\n')),(0,i.kt)("p",null,"Any ",(0,i.kt)("inlineCode",{parentName:"p"},"setDefault")," without a load hint (the 1st example) must be synchronous, and will be ",(0,i.kt)("em",{parentName:"p"},"applied immediately")," upon creation, i.e. ",(0,i.kt)("inlineCode",{parentName:"p"},"em.create")," calls, just like the schema default values."),(0,i.kt)("p",null,"Any ",(0,i.kt)("inlineCode",{parentName:"p"},"setDefault")," with a load hint (the 2nd exmaple) can be asynchronous, and will ",(0,i.kt)("em",{parentName:"p"},"not be applied until ",(0,i.kt)("inlineCode",{parentName:"em"},"em.flush()")),", because the ",(0,i.kt)("inlineCode",{parentName:"p"},"async")," nature means we have to wait to invoke them."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"We could probably add an async ",(0,i.kt)("inlineCode",{parentName:"p"},"em.assignDefaults"),", similar to ",(0,i.kt)("inlineCode",{parentName:"p"},"em.assignNewIds"),", to allow code to trigger async default assignment, without kicking off an ",(0,i.kt)("inlineCode",{parentName:"p"},"em.flush"),".")),(0,i.kt)("h3",{id:"hooks"},"Hooks"),(0,i.kt)("p",null,"You can also use ",(0,i.kt)("inlineCode",{parentName:"p"},"beforeCreate")," hooks to apply defaults, but ",(0,i.kt)("inlineCode",{parentName:"p"},"setDefault")," is preferred because it's the most accurate modeling of intent, and follows our general recommendation to use hooks sparingly."))}u.isMDXComponent=!0}}]);